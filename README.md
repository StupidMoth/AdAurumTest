# AdAurum - Тестовое задание на позицию Junior разработчик Unity

## Текст задания:
Вам необходимо создать простую игру-квиз в Unity с использованием JSON файла для
хранения вопросов и фона для каждого вопроса. В игре должны быть следующие особенности:  
1. Главное меню: экран с кнопкой "Начать игру", которая перенаправляет пользователя
на первый вопрос.  
2. Вопросы: для каждого вопроса должен быть уникальный фон и текстовое поле с
вопросом. Варианты ответов также должны быть представлены на экране.  
3. Правильный и неправильный ответ: после того, как пользователь выберет ответ,
игра должна отобразить экран с сообщением "Верно" или "Неверно". Экран должен
также содержать кнопку "Далее", которая перенаправляет пользователя на следующий
вопрос.  
4. Результаты: после того, как пользователь ответит на все вопросы, игра должна
показать экран с результатами, отображающим количество правильных ответов и
кнопкой "Новая игра", которая перенаправляет пользователя на главный экран.
Для реализации данной игры вы можете использовать любые возможности Unity, включая
графический интерфейс, скрипты, JSON-файлы и т.д.  

Пример структуры JSON-файла: 
```json
[
 {
 "question": "Какая страна самая большая в мире?",
 "answers": [
 {"text": "Россия", "correct": true},
 {"text": "США", "correct": false},
 {"text": "Китай", "correct": false},
 {"text": "Канада", "correct": false}
 ],
 "background": "backgrounds/russia.jpg"
 },
 {
 "question": "Какой металл самый тяжелый?",
 "answers": [
 {"text": "Золото", "correct": false},
 {"text": "Платина", "correct": false},
 {"text": "Олово", "correct": false},
 {"text": "Осмий", "correct": true}
 ],
 "background": "backgrounds/osmium.jpg"
 },
]
```

## Использованные технические средства
1. Unity 2022.3.10f1
2. VContainer 1.13.2
3. Newtonsoft.Json 3.0.1

## Работа с внешними ресурсами
Т.к. из формулировки технического задания нельзя было сделать однозначный вывод о том, где именно должны храниться json-файл с вопросами и фоновые изображения, я предположил, что json формат был выбран для удобного редактирования контента дизайнерами/редакторами. Исходя из этого предположения, я остановился на выборе директории StreamingAssets, т.к. ресурсы в ней можно легко подменять даже в уже скомпилированном проекте. Также я выделил отдельные интерфейсы Loader'ов, реализовав которые иначе, можно будет подменить работу со StreamingAssets на Resources, Asset Bundles, Addressables или что-то другое.  
Кроме того, я добавил кеширование уже загруженных в рантайме спрайтов для SpriteLoader'a, чтобы избежать лишних операций преобразования изображений из директории backgrounds в Sprite'ы.  

## Подход к работе с экранами
Для управления экранами приложения я выбрал подход с использованием простой машины состояний. Выбор обусловлен потенциальной возможностью расширения приложения путем добавления новых экранов к уже существующим. Также для изоляции слоя UI от основной геймплейной логики был использован медиатор ScreensMediator.

## Конфигурация игры
Помимо возможности указать относительные пути для внешних ассетов, GameConfig позволяет выбрать две дополнительные опции:
1. Shuffle Slides - перемешивает порядок вывода слайдов с вопросами;
2. Shuffle Answers - перемешивает порядок кнопок с ответами.

![image](https://github.com/StupidMoth/AdAurumTest/assets/57850032/e47ac61d-4627-411c-ab69-00be817c58e0)

## Внедрение зависимостей
Т.к. на большинстве Unity проектов используется один из распространенных DI-контейнеров, я решил, что следует продемонстрировать наличие навыков работы с ними на примере VContainer'а.  
С помощью SceneLifetimeScope можно легко подменять реализации некоторых интерфейсов, используемых в проекте:

```cs
        builder
            .Register<NewtonsoftJsonSerializer>(Lifetime.Singleton)
            .As<IJsonSerializer>();
```

Также я написал небольшой Helper, который в режиме редактирования на лету добавляет GameObject'ы со сцены, которые содержат в одном из компонентов [Inject] аттрибут на Construct-методе (также для Construct-методов я применял те же правила код-стайла, что и для настоящих конструкторов: в частности это касается порядка сортировки членов класса).

